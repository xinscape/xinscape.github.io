<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>抽象水彩漂浮薄片 Demo</title>
<style>
  body { font-family: sans-serif; display: flex; }
  canvas { border: 1px solid #ccc; margin-right: 20px; }
  .controls { display: flex; flex-direction: column; gap: 10px; }
</style>
</head>
<body>

<canvas id="canvas" width="600" height="600"></canvas>

<div class="controls">
  <label>主色调: <input type="color" id="mainColor" value="#f5f5f5"></label>
  <label>漂浮度: <input type="range" id="floatRange" min="0" max="1" step="0.01" value="0.5"></label>
  <label>透明度: <input type="range" id="alphaRange" min="0" max="1" step="0.01" value="0.6"></label>
  <label>留白: <input type="range" id="sparseRange" min="0" max="1" step="0.01" value="0.7"></label>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let particles = [];
const particleCount = 50;

// 初始化薄片对象
function initParticles() {
  particles = [];
  for (let i = 0; i < particleCount; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: 10 + Math.random() * 20,
      driftX: (Math.random() - 0.5) * 1,
      driftY: (Math.random() - 0.5) * 1,
    });
  }
}

initParticles();

// 渲染函数
function draw() {
  // 留白控制背景透明度
  const sparse = parseFloat(document.getElementById('sparseRange').value);
  ctx.fillStyle = `rgba(255,255,255,${sparse})`;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  const mainColor = document.getElementById('mainColor').value;
  const alpha = parseFloat(document.getElementById('alphaRange').value);
  const floatAmount = parseFloat(document.getElementById('floatRange').value);

  particles.forEach(p => {
    // 漂浮微动
    p.x += p.driftX * floatAmount * 2;
    p.y += p.driftY * floatAmount * 2;

    // 循环回到画布内
    if(p.x < 0) p.x = canvas.width;
    if(p.x > canvas.width) p.x = 0;
    if(p.y < 0) p.y = canvas.height;
    if(p.y > canvas.height) p.y = 0;

    // 绘制薄片
    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
    gradient.addColorStop(0, mainColor + Math.floor(alpha*255).toString(16).padStart(2,'0'));
    gradient.addColorStop(1, mainColor + '00');
    ctx.fillStyle = gradient;

    ctx.beginPath();
    ctx.ellipse(p.x, p.y, p.size, p.size*0.6, Math.random()*Math.PI, 0, 2*Math.PI);
    ctx.fill();
  });

  requestAnimationFrame(draw);
}

// 事件监听滑条
document.getElementById('mainColor').addEventListener('input', () => {});
document.getElementById('floatRange').addEventListener('input', () => {});
document.getElementById('alphaRange').addEventListener('input', () => {});
document.getElementById('sparseRange').addEventListener('input', () => {});

draw();
</script>
</body>
</html>

